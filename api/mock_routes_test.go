// Code generated by MockGen. DO NOT EDIT.
// Source: routes.go

// Package api is a generated GoMock package.
package api

import (
	http "net/http"
	reflect "reflect"

	gin "github.com/gin-gonic/gin"
	gomock "github.com/golang/mock/gomock"
)

// MockmethodRegistrar is a mock of methodRegistrar interface.
type MockmethodRegistrar struct {
	ctrl     *gomock.Controller
	recorder *MockmethodRegistrarMockRecorder
}

// MockmethodRegistrarMockRecorder is the mock recorder for MockmethodRegistrar.
type MockmethodRegistrarMockRecorder struct {
	mock *MockmethodRegistrar
}

// NewMockmethodRegistrar creates a new mock instance.
func NewMockmethodRegistrar(ctrl *gomock.Controller) *MockmethodRegistrar {
	mock := &MockmethodRegistrar{ctrl: ctrl}
	mock.recorder = &MockmethodRegistrarMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockmethodRegistrar) EXPECT() *MockmethodRegistrarMockRecorder {
	return m.recorder
}

// Any mocks base method.
func (m *MockmethodRegistrar) Any(arg0 string, arg1 ...gin.HandlerFunc) gin.IRoutes {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Any", varargs...)
	ret0, _ := ret[0].(gin.IRoutes)
	return ret0
}

// Any indicates an expected call of Any.
func (mr *MockmethodRegistrarMockRecorder) Any(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Any", reflect.TypeOf((*MockmethodRegistrar)(nil).Any), varargs...)
}

// DELETE mocks base method.
func (m *MockmethodRegistrar) DELETE(arg0 string, arg1 ...gin.HandlerFunc) gin.IRoutes {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DELETE", varargs...)
	ret0, _ := ret[0].(gin.IRoutes)
	return ret0
}

// DELETE indicates an expected call of DELETE.
func (mr *MockmethodRegistrarMockRecorder) DELETE(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DELETE", reflect.TypeOf((*MockmethodRegistrar)(nil).DELETE), varargs...)
}

// GET mocks base method.
func (m *MockmethodRegistrar) GET(arg0 string, arg1 ...gin.HandlerFunc) gin.IRoutes {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GET", varargs...)
	ret0, _ := ret[0].(gin.IRoutes)
	return ret0
}

// GET indicates an expected call of GET.
func (mr *MockmethodRegistrarMockRecorder) GET(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GET", reflect.TypeOf((*MockmethodRegistrar)(nil).GET), varargs...)
}

// HEAD mocks base method.
func (m *MockmethodRegistrar) HEAD(arg0 string, arg1 ...gin.HandlerFunc) gin.IRoutes {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "HEAD", varargs...)
	ret0, _ := ret[0].(gin.IRoutes)
	return ret0
}

// HEAD indicates an expected call of HEAD.
func (mr *MockmethodRegistrarMockRecorder) HEAD(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HEAD", reflect.TypeOf((*MockmethodRegistrar)(nil).HEAD), varargs...)
}

// Handle mocks base method.
func (m *MockmethodRegistrar) Handle(arg0, arg1 string, arg2 ...gin.HandlerFunc) gin.IRoutes {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Handle", varargs...)
	ret0, _ := ret[0].(gin.IRoutes)
	return ret0
}

// Handle indicates an expected call of Handle.
func (mr *MockmethodRegistrarMockRecorder) Handle(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Handle", reflect.TypeOf((*MockmethodRegistrar)(nil).Handle), varargs...)
}

// OPTIONS mocks base method.
func (m *MockmethodRegistrar) OPTIONS(arg0 string, arg1 ...gin.HandlerFunc) gin.IRoutes {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "OPTIONS", varargs...)
	ret0, _ := ret[0].(gin.IRoutes)
	return ret0
}

// OPTIONS indicates an expected call of OPTIONS.
func (mr *MockmethodRegistrarMockRecorder) OPTIONS(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OPTIONS", reflect.TypeOf((*MockmethodRegistrar)(nil).OPTIONS), varargs...)
}

// PATCH mocks base method.
func (m *MockmethodRegistrar) PATCH(arg0 string, arg1 ...gin.HandlerFunc) gin.IRoutes {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PATCH", varargs...)
	ret0, _ := ret[0].(gin.IRoutes)
	return ret0
}

// PATCH indicates an expected call of PATCH.
func (mr *MockmethodRegistrarMockRecorder) PATCH(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PATCH", reflect.TypeOf((*MockmethodRegistrar)(nil).PATCH), varargs...)
}

// POST mocks base method.
func (m *MockmethodRegistrar) POST(arg0 string, arg1 ...gin.HandlerFunc) gin.IRoutes {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "POST", varargs...)
	ret0, _ := ret[0].(gin.IRoutes)
	return ret0
}

// POST indicates an expected call of POST.
func (mr *MockmethodRegistrarMockRecorder) POST(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "POST", reflect.TypeOf((*MockmethodRegistrar)(nil).POST), varargs...)
}

// PUT mocks base method.
func (m *MockmethodRegistrar) PUT(arg0 string, arg1 ...gin.HandlerFunc) gin.IRoutes {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PUT", varargs...)
	ret0, _ := ret[0].(gin.IRoutes)
	return ret0
}

// PUT indicates an expected call of PUT.
func (mr *MockmethodRegistrarMockRecorder) PUT(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PUT", reflect.TypeOf((*MockmethodRegistrar)(nil).PUT), varargs...)
}

// Static mocks base method.
func (m *MockmethodRegistrar) Static(arg0, arg1 string) gin.IRoutes {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Static", arg0, arg1)
	ret0, _ := ret[0].(gin.IRoutes)
	return ret0
}

// Static indicates an expected call of Static.
func (mr *MockmethodRegistrarMockRecorder) Static(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Static", reflect.TypeOf((*MockmethodRegistrar)(nil).Static), arg0, arg1)
}

// StaticFS mocks base method.
func (m *MockmethodRegistrar) StaticFS(arg0 string, arg1 http.FileSystem) gin.IRoutes {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StaticFS", arg0, arg1)
	ret0, _ := ret[0].(gin.IRoutes)
	return ret0
}

// StaticFS indicates an expected call of StaticFS.
func (mr *MockmethodRegistrarMockRecorder) StaticFS(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StaticFS", reflect.TypeOf((*MockmethodRegistrar)(nil).StaticFS), arg0, arg1)
}

// StaticFile mocks base method.
func (m *MockmethodRegistrar) StaticFile(arg0, arg1 string) gin.IRoutes {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StaticFile", arg0, arg1)
	ret0, _ := ret[0].(gin.IRoutes)
	return ret0
}

// StaticFile indicates an expected call of StaticFile.
func (mr *MockmethodRegistrarMockRecorder) StaticFile(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StaticFile", reflect.TypeOf((*MockmethodRegistrar)(nil).StaticFile), arg0, arg1)
}

// Use mocks base method.
func (m *MockmethodRegistrar) Use(arg0 ...gin.HandlerFunc) gin.IRoutes {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Use", varargs...)
	ret0, _ := ret[0].(gin.IRoutes)
	return ret0
}

// Use indicates an expected call of Use.
func (mr *MockmethodRegistrarMockRecorder) Use(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Use", reflect.TypeOf((*MockmethodRegistrar)(nil).Use), arg0...)
}
